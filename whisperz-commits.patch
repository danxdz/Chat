From d33d57a1323a15cc1c2dfda0b41b4ccd0ec6dae1 Mon Sep 17 00:00:00 2001
From: User <user@example.com>
Date: Thu, 14 Aug 2025 11:44:42 +0000
Subject: [PATCH 1/3] Initial commit for Whisperz project

---
 .gitignore | 84 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 README.md  | 28 ++++++++++++++++++
 2 files changed, 112 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 README.md

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..9ac54a6
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,84 @@
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+
+# Virtual environments
+venv/
+ENV/
+env/
+.venv
+
+# IDE specific files
+.vscode/
+.idea/
+*.swp
+*.swo
+*~
+.DS_Store
+
+# Node
+node_modules/
+npm-debug.log*
+yarn-debug.log*
+yarn-error.log*
+
+# Logs
+*.log
+logs/
+
+# Environment variables
+.env
+.env.local
+.env.*.local
+
+# Database
+*.db
+*.sqlite
+*.sqlite3
+
+# Temporary files
+tmp/
+temp/
+*.tmp
+*.temp
+
+# Coverage reports
+htmlcov/
+.coverage
+.coverage.*
+coverage.xml
+*.cover
+
+# Testing
+.pytest_cache/
+.tox/
+
+# Build artifacts
+*.o
+*.exe
+*.dll
+*.class
+target/
+out/
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..5941a43
--- /dev/null
+++ b/README.md
@@ -0,0 +1,28 @@
+# Whisperz
+
+Welcome to the Whisperz project!
+
+## Description
+
+This is the Whisperz repository.
+
+## Getting Started
+
+### Prerequisites
+
+- Git
+
+### Installation
+
+```bash
+git clone <repository-url>
+cd whisperz
+```
+
+## Contributing
+
+Contributions are welcome!
+
+## License
+
+This project is licensed under the MIT License.
\ No newline at end of file
-- 
2.48.1


From 553221436233d57e74361983fb8e0510fea2a54d Mon Sep 17 00:00:00 2001
From: User <user@example.com>
Date: Thu, 14 Aug 2025 11:50:01 +0000
Subject: [PATCH 2/3] feat: Initial modular architecture for Whisperz P2P chat

- Set up core module system with ModuleManager for easy extensibility
- Implemented Gun.js module for decentralized data management
  - User authentication with SEA (Security, Encryption, Authorization)
  - Contact management
  - Chat room functionality
  - Real-time data synchronization
- Implemented WebRTC module for secure P2P communication
  - SimplePeer integration for easy WebRTC handling
  - Signaling through Gun.js
  - Support for chat messages, file transfer, and typing indicators
  - Automatic peer connection management
- Added package.json with all necessary dependencies
- Created modular architecture for easy feature additions
---
 package.json                |  35 +++
 src/core/ModuleManager.js   | 202 +++++++++++++++++
 src/modules/GunModule.js    | 334 ++++++++++++++++++++++++++++
 src/modules/WebRTCModule.js | 422 ++++++++++++++++++++++++++++++++++++
 4 files changed, 993 insertions(+)
 create mode 100644 package.json
 create mode 100644 src/core/ModuleManager.js
 create mode 100644 src/modules/GunModule.js
 create mode 100644 src/modules/WebRTCModule.js

diff --git a/package.json b/package.json
new file mode 100644
index 0000000..0cec09f
--- /dev/null
+++ b/package.json
@@ -0,0 +1,35 @@
+{
+  "name": "whisperz",
+  "version": "0.1.0",
+  "description": "Decentralized P2P chat using Gun.js and WebRTC",
+  "type": "module",
+  "main": "src/index.js",
+  "scripts": {
+    "dev": "vite",
+    "build": "vite build",
+    "preview": "vite preview",
+    "serve": "node server/index.js"
+  },
+  "keywords": [
+    "p2p",
+    "decentralized",
+    "chat",
+    "gun",
+    "webrtc",
+    "encrypted"
+  ],
+  "author": "",
+  "license": "MIT",
+  "dependencies": {
+    "gun": "^0.2020.1240",
+    "simple-peer": "^9.11.1",
+    "eventemitter3": "^5.0.1",
+    "uuid": "^9.0.1",
+    "dompurify": "^3.0.6"
+  },
+  "devDependencies": {
+    "vite": "^5.0.10",
+    "express": "^4.18.2",
+    "@vitejs/plugin-legacy": "^5.2.0"
+  }
+}
\ No newline at end of file
diff --git a/src/core/ModuleManager.js b/src/core/ModuleManager.js
new file mode 100644
index 0000000..98a6a00
--- /dev/null
+++ b/src/core/ModuleManager.js
@@ -0,0 +1,202 @@
+/**
+ * ModuleManager - Core module system for Whisperz
+ * Handles module registration, initialization, and inter-module communication
+ */
+
+import EventEmitter from 'eventemitter3';
+
+class ModuleManager extends EventEmitter {
+  constructor() {
+    super();
+    this.modules = new Map();
+    this.moduleStates = new Map();
+    this.dependencies = new Map();
+    this.config = {};
+  }
+
+  /**
+   * Register a module with the manager
+   * @param {string} name - Module name
+   * @param {Object} module - Module instance or class
+   * @param {Array} dependencies - Array of module names this module depends on
+   */
+  async register(name, module, dependencies = []) {
+    if (this.modules.has(name)) {
+      console.warn(`Module ${name} is already registered`);
+      return;
+    }
+
+    this.modules.set(name, module);
+    this.dependencies.set(name, dependencies);
+    this.moduleStates.set(name, 'registered');
+    
+    this.emit('module:registered', { name, module });
+    console.log(`Module registered: ${name}`);
+  }
+
+  /**
+   * Initialize a specific module
+   * @param {string} name - Module name to initialize
+   */
+  async initializeModule(name) {
+    const module = this.modules.get(name);
+    if (!module) {
+      throw new Error(`Module ${name} not found`);
+    }
+
+    const state = this.moduleStates.get(name);
+    if (state === 'initialized' || state === 'initializing') {
+      return module;
+    }
+
+    // Check and initialize dependencies first
+    const deps = this.dependencies.get(name) || [];
+    for (const dep of deps) {
+      if (!this.modules.has(dep)) {
+        throw new Error(`Dependency ${dep} for module ${name} not found`);
+      }
+      await this.initializeModule(dep);
+    }
+
+    this.moduleStates.set(name, 'initializing');
+    
+    try {
+      // If module has an init method, call it
+      if (typeof module.init === 'function') {
+        await module.init(this);
+      }
+      
+      this.moduleStates.set(name, 'initialized');
+      this.emit('module:initialized', { name, module });
+      console.log(`Module initialized: ${name}`);
+      
+      return module;
+    } catch (error) {
+      this.moduleStates.set(name, 'failed');
+      this.emit('module:error', { name, error });
+      throw new Error(`Failed to initialize module ${name}: ${error.message}`);
+    }
+  }
+
+  /**
+   * Initialize all registered modules
+   */
+  async initializeAll() {
+    const moduleNames = Array.from(this.modules.keys());
+    
+    for (const name of moduleNames) {
+      try {
+        await this.initializeModule(name);
+      } catch (error) {
+        console.error(`Failed to initialize module ${name}:`, error);
+      }
+    }
+  }
+
+  /**
+   * Get a module by name
+   * @param {string} name - Module name
+   * @returns {Object} Module instance
+   */
+  getModule(name) {
+    const module = this.modules.get(name);
+    if (!module) {
+      throw new Error(`Module ${name} not found`);
+    }
+    
+    const state = this.moduleStates.get(name);
+    if (state !== 'initialized') {
+      console.warn(`Module ${name} is not initialized yet (state: ${state})`);
+    }
+    
+    return module;
+  }
+
+  /**
+   * Check if a module is registered
+   * @param {string} name - Module name
+   * @returns {boolean}
+   */
+  hasModule(name) {
+    return this.modules.has(name);
+  }
+
+  /**
+   * Get module state
+   * @param {string} name - Module name
+   * @returns {string} Module state
+   */
+  getModuleState(name) {
+    return this.moduleStates.get(name);
+  }
+
+  /**
+   * Unload a module
+   * @param {string} name - Module name
+   */
+  async unloadModule(name) {
+    const module = this.modules.get(name);
+    if (!module) {
+      return;
+    }
+
+    // Check if other modules depend on this one
+    for (const [modName, deps] of this.dependencies) {
+      if (deps.includes(name) && this.moduleStates.get(modName) === 'initialized') {
+        throw new Error(`Cannot unload ${name}: ${modName} depends on it`);
+      }
+    }
+
+    // Call cleanup if available
+    if (typeof module.cleanup === 'function') {
+      await module.cleanup();
+    }
+
+    this.modules.delete(name);
+    this.moduleStates.delete(name);
+    this.dependencies.delete(name);
+    
+    this.emit('module:unloaded', { name });
+    console.log(`Module unloaded: ${name}`);
+  }
+
+  /**
+   * Set global configuration
+   * @param {Object} config - Configuration object
+   */
+  setConfig(config) {
+    this.config = { ...this.config, ...config };
+    this.emit('config:updated', this.config);
+  }
+
+  /**
+   * Get configuration
+   * @returns {Object} Configuration object
+   */
+  getConfig() {
+    return this.config;
+  }
+
+  /**
+   * List all modules and their states
+   * @returns {Array} Array of module info
+   */
+  listModules() {
+    const moduleList = [];
+    for (const [name, module] of this.modules) {
+      moduleList.push({
+        name,
+        state: this.moduleStates.get(name),
+        dependencies: this.dependencies.get(name) || [],
+        hasInit: typeof module.init === 'function',
+        hasCleanup: typeof module.cleanup === 'function'
+      });
+    }
+    return moduleList;
+  }
+}
+
+// Create singleton instance
+const moduleManager = new ModuleManager();
+
+export default moduleManager;
\ No newline at end of file
diff --git a/src/modules/GunModule.js b/src/modules/GunModule.js
new file mode 100644
index 0000000..7f7d762
--- /dev/null
+++ b/src/modules/GunModule.js
@@ -0,0 +1,334 @@
+/**
+ * GunModule - Gun.js integration for decentralized data management
+ * Handles user authentication, data persistence, and peer synchronization
+ */
+
+import Gun from 'gun/gun';
+import 'gun/sea'; // Security, Encryption, Authorization
+import 'gun/axe'; // For debugging
+import EventEmitter from 'eventemitter3';
+
+class GunModule extends EventEmitter {
+  constructor() {
+    super();
+    this.gun = null;
+    this.user = null;
+    this.peers = [];
+    this.isAuthenticated = false;
+    this.userData = null;
+  }
+
+  /**
+   * Initialize Gun.js with peer configuration
+   * @param {Object} moduleManager - Reference to module manager
+   */
+  async init(moduleManager) {
+    this.moduleManager = moduleManager;
+    const config = moduleManager.getConfig();
+    
+    // Initialize Gun with peers
+    const peers = config.gunPeers || [
+      'https://gun-manhattan.herokuapp.com/gun',
+      'https://gun-matrix.herokuapp.com/gun',
+      'https://gun.dirtbag.dev/gun',
+      'https://gundb-relay-mlccl.ondigitalocean.app/gun'
+    ];
+
+    this.gun = Gun({
+      peers: peers,
+      localStorage: true,
+      radisk: true,
+      WebRTC: { iceServers: config.iceServers },
+      axe: false // Set to true for debugging
+    });
+
+    this.user = this.gun.user();
+    
+    // Set up authentication listeners
+    this.setupAuthListeners();
+    
+    console.log('Gun.js initialized with peers:', peers);
+    this.emit('gun:initialized', { peers });
+  }
+
+  /**
+   * Set up authentication event listeners
+   */
+  setupAuthListeners() {
+    this.gun.on('auth', () => {
+      this.isAuthenticated = true;
+      this.emit('auth:success');
+      console.log('User authenticated');
+      this.loadUserData();
+    });
+
+    this.gun.on('auth-fail', (error) => {
+      this.isAuthenticated = false;
+      this.emit('auth:failed', error);
+      console.error('Authentication failed:', error);
+    });
+  }
+
+  /**
+   * Create a new user account
+   * @param {string} username - Username
+   * @param {string} password - Password
+   * @returns {Promise} Resolution of user creation
+   */
+  async createUser(username, password) {
+    return new Promise((resolve, reject) => {
+      this.user.create(username, password, (ack) => {
+        if (ack.err) {
+          this.emit('user:create:failed', ack.err);
+          reject(new Error(ack.err));
+        } else {
+          this.emit('user:created', { username });
+          console.log('User created:', username);
+          // Auto-login after creation
+          this.login(username, password).then(resolve).catch(reject);
+        }
+      });
+    });
+  }
+
+  /**
+   * Login with existing credentials
+   * @param {string} username - Username
+   * @param {string} password - Password
+   * @returns {Promise} Resolution of login
+   */
+  async login(username, password) {
+    return new Promise((resolve, reject) => {
+      this.user.auth(username, password, (ack) => {
+        if (ack.err) {
+          this.emit('auth:failed', ack.err);
+          reject(new Error(ack.err));
+        } else {
+          this.isAuthenticated = true;
+          this.userData = ack;
+          this.emit('auth:success', { username, pub: ack.sea.pub });
+          resolve(ack);
+        }
+      });
+    });
+  }
+
+  /**
+   * Logout current user
+   */
+  logout() {
+    this.user.leave();
+    this.isAuthenticated = false;
+    this.userData = null;
+    this.emit('auth:logout');
+    console.log('User logged out');
+  }
+
+  /**
+   * Load user data after authentication
+   */
+  loadUserData() {
+    if (!this.isAuthenticated) return;
+
+    // Load user profile
+    this.user.get('profile').on((data) => {
+      this.emit('user:profile:updated', data);
+    });
+
+    // Load user contacts
+    this.user.get('contacts').map().on((contact, id) => {
+      this.emit('user:contact:updated', { id, contact });
+    });
+
+    // Load user chats
+    this.user.get('chats').map().on((chat, id) => {
+      this.emit('user:chat:updated', { id, chat });
+    });
+  }
+
+  /**
+   * Update user profile
+   * @param {Object} profile - Profile data
+   */
+  async updateProfile(profile) {
+    if (!this.isAuthenticated) {
+      throw new Error('User not authenticated');
+    }
+
+    await this.user.get('profile').put(profile);
+    this.emit('user:profile:saved', profile);
+  }
+
+  /**
+   * Get user's public key
+   * @returns {string} Public key
+   */
+  getPublicKey() {
+    if (!this.isAuthenticated || !this.userData) {
+      return null;
+    }
+    return this.userData.sea.pub;
+  }
+
+  /**
+   * Add a contact
+   * @param {string} publicKey - Contact's public key
+   * @param {Object} contactInfo - Contact information
+   */
+  async addContact(publicKey, contactInfo) {
+    if (!this.isAuthenticated) {
+      throw new Error('User not authenticated');
+    }
+
+    const contact = {
+      ...contactInfo,
+      publicKey,
+      addedAt: Date.now()
+    };
+
+    await this.user.get('contacts').get(publicKey).put(contact);
+    this.emit('contact:added', contact);
+  }
+
+  /**
+   * Remove a contact
+   * @param {string} publicKey - Contact's public key
+   */
+  async removeContact(publicKey) {
+    if (!this.isAuthenticated) {
+      throw new Error('User not authenticated');
+    }
+
+    await this.user.get('contacts').get(publicKey).put(null);
+    this.emit('contact:removed', publicKey);
+  }
+
+  /**
+   * Get all contacts
+   * @returns {Promise<Object>} Contacts object
+   */
+  async getContacts() {
+    if (!this.isAuthenticated) {
+      throw new Error('User not authenticated');
+    }
+
+    return new Promise((resolve) => {
+      const contacts = {};
+      this.user.get('contacts').map().once((contact, id) => {
+        if (contact) {
+          contacts[id] = contact;
+        }
+      });
+      setTimeout(() => resolve(contacts), 500); // Wait for data to load
+    });
+  }
+
+  /**
+   * Create or get a chat room
+   * @param {string} roomId - Room identifier
+   * @returns {Object} Chat room reference
+   */
+  getChatRoom(roomId) {
+    return this.gun.get('chats').get(roomId);
+  }
+
+  /**
+   * Send a message to a chat room
+   * @param {string} roomId - Room identifier
+   * @param {Object} message - Message object
+   */
+  async sendMessage(roomId, message) {
+    if (!this.isAuthenticated) {
+      throw new Error('User not authenticated');
+    }
+
+    const messageData = {
+      ...message,
+      from: this.getPublicKey(),
+      timestamp: Date.now(),
+      id: Gun.node.Soul.uuid()
+    };
+
+    // Save to chat room
+    await this.getChatRoom(roomId).get('messages').get(messageData.id).put(messageData);
+    
+    // Save reference in user's chats
+    await this.user.get('chats').get(roomId).get('messages').get(messageData.id).put(true);
+    
+    this.emit('message:sent', { roomId, message: messageData });
+    return messageData;
+  }
+
+  /**
+   * Subscribe to messages in a chat room
+   * @param {string} roomId - Room identifier
+   * @param {Function} callback - Callback for new messages
+   */
+  subscribeToRoom(roomId, callback) {
+    const room = this.getChatRoom(roomId);
+    
+    room.get('messages').map().on((message, id) => {
+      if (message && typeof message === 'object') {
+        callback({ ...message, id });
+        this.emit('message:received', { roomId, message: { ...message, id } });
+      }
+    });
+
+    // Also subscribe to typing indicators
+    room.get('typing').on((data) => {
+      this.emit('room:typing', { roomId, data });
+    });
+  }
+
+  /**
+   * Set typing indicator
+   * @param {string} roomId - Room identifier
+   * @param {boolean} isTyping - Typing state
+   */
+  async setTyping(roomId, isTyping) {
+    if (!this.isAuthenticated) return;
+
+    const typingData = {
+      user: this.getPublicKey(),
+      isTyping,
+      timestamp: Date.now()
+    };
+
+    await this.getChatRoom(roomId).get('typing').get(this.getPublicKey()).put(typingData);
+  }
+
+  /**
+   * Get Gun instance for direct access
+   * @returns {Object} Gun instance
+   */
+  getGun() {
+    return this.gun;
+  }
+
+  /**
+   * Get User instance for direct access
+   * @returns {Object} User instance
+   */
+  getUser() {
+    return this.user;
+  }
+
+  /**
+   * Clean up module
+   */
+  async cleanup() {
+    if (this.isAuthenticated) {
+      this.logout();
+    }
+    
+    // Close Gun connections
+    if (this.gun) {
+      this.gun.off();
+    }
+    
+    this.removeAllListeners();
+    console.log('Gun module cleaned up');
+  }
+}
+
+export default new GunModule();
\ No newline at end of file
diff --git a/src/modules/WebRTCModule.js b/src/modules/WebRTCModule.js
new file mode 100644
index 0000000..ab970fd
--- /dev/null
+++ b/src/modules/WebRTCModule.js
@@ -0,0 +1,422 @@
+/**
+ * WebRTCModule - WebRTC integration for secure P2P messaging
+ * Handles peer connections, signaling, and encrypted communication
+ */
+
+import SimplePeer from 'simple-peer';
+import EventEmitter from 'eventemitter3';
+import { v4 as uuidv4 } from 'uuid';
+
+class WebRTCModule extends EventEmitter {
+  constructor() {
+    super();
+    this.peers = new Map();
+    this.pendingOffers = new Map();
+    this.gunModule = null;
+    this.moduleManager = null;
+    this.iceServers = [
+      { urls: 'stun:stun.l.google.com:19302' },
+      { urls: 'stun:stun1.l.google.com:19302' }
+    ];
+  }
+
+  /**
+   * Initialize WebRTC module
+   * @param {Object} moduleManager - Reference to module manager
+   */
+  async init(moduleManager) {
+    this.moduleManager = moduleManager;
+    this.gunModule = moduleManager.getModule('gun');
+    
+    const config = moduleManager.getConfig();
+    if (config.iceServers) {
+      this.iceServers = config.iceServers;
+    }
+
+    // Listen for Gun.js signaling messages
+    this.setupSignaling();
+    
+    console.log('WebRTC module initialized');
+    this.emit('webrtc:initialized');
+  }
+
+  /**
+   * Set up signaling through Gun.js
+   */
+  setupSignaling() {
+    if (!this.gunModule || !this.gunModule.isAuthenticated) {
+      console.warn('Gun module not authenticated, skipping signaling setup');
+      return;
+    }
+
+    const user = this.gunModule.getUser();
+    const myPubKey = this.gunModule.getPublicKey();
+
+    // Listen for incoming signals
+    user.get('signals').map().on((signal, id) => {
+      if (signal && signal.from !== myPubKey) {
+        this.handleSignal(signal);
+      }
+    });
+
+    console.log('WebRTC signaling set up');
+  }
+
+  /**
+   * Create a peer connection
+   * @param {string} targetPubKey - Target peer's public key
+   * @param {boolean} initiator - Whether this peer initiates the connection
+   * @returns {SimplePeer} Peer instance
+   */
+  createPeer(targetPubKey, initiator = true) {
+    // Check if peer already exists
+    if (this.peers.has(targetPubKey)) {
+      console.log('Peer already exists:', targetPubKey);
+      return this.peers.get(targetPubKey);
+    }
+
+    const peer = new SimplePeer({
+      initiator,
+      trickle: false,
+      config: {
+        iceServers: this.iceServers
+      }
+    });
+
+    // Store peer
+    this.peers.set(targetPubKey, peer);
+
+    // Set up peer event handlers
+    this.setupPeerHandlers(peer, targetPubKey);
+
+    console.log(`Peer created for ${targetPubKey} (initiator: ${initiator})`);
+    return peer;
+  }
+
+  /**
+   * Set up event handlers for a peer
+   * @param {SimplePeer} peer - Peer instance
+   * @param {string} targetPubKey - Target peer's public key
+   */
+  setupPeerHandlers(peer, targetPubKey) {
+    // When peer generates signaling data
+    peer.on('signal', (data) => {
+      this.sendSignal(targetPubKey, data);
+    });
+
+    // When peer connection is established
+    peer.on('connect', () => {
+      console.log(`Connected to peer: ${targetPubKey}`);
+      this.emit('peer:connected', { pubKey: targetPubKey, peer });
+      
+      // Send a test message
+      peer.send(JSON.stringify({
+        type: 'connection',
+        message: 'Connected successfully',
+        timestamp: Date.now()
+      }));
+    });
+
+    // When receiving data from peer
+    peer.on('data', (data) => {
+      try {
+        const message = JSON.parse(data.toString());
+        this.handlePeerMessage(targetPubKey, message);
+      } catch (error) {
+        console.error('Error parsing peer message:', error);
+      }
+    });
+
+    // Handle errors
+    peer.on('error', (error) => {
+      console.error(`Peer error with ${targetPubKey}:`, error);
+      this.emit('peer:error', { pubKey: targetPubKey, error });
+      this.removePeer(targetPubKey);
+    });
+
+    // Handle peer close
+    peer.on('close', () => {
+      console.log(`Peer closed: ${targetPubKey}`);
+      this.emit('peer:closed', { pubKey: targetPubKey });
+      this.removePeer(targetPubKey);
+    });
+
+    // Handle streams (for future video/audio support)
+    peer.on('stream', (stream) => {
+      this.emit('peer:stream', { pubKey: targetPubKey, stream });
+    });
+  }
+
+  /**
+   * Send signaling data through Gun.js
+   * @param {string} targetPubKey - Target peer's public key
+   * @param {Object} signalData - Signaling data
+   */
+  async sendSignal(targetPubKey, signalData) {
+    if (!this.gunModule || !this.gunModule.isAuthenticated) {
+      console.error('Cannot send signal: not authenticated');
+      return;
+    }
+
+    const myPubKey = this.gunModule.getPublicKey();
+    const signal = {
+      from: myPubKey,
+      to: targetPubKey,
+      data: signalData,
+      timestamp: Date.now(),
+      id: uuidv4()
+    };
+
+    // Send to target's signal inbox
+    const gun = this.gunModule.getGun();
+    await gun.user(targetPubKey).get('signals').get(signal.id).put(signal);
+    
+    console.log(`Signal sent to ${targetPubKey}`);
+    this.emit('signal:sent', signal);
+  }
+
+  /**
+   * Handle incoming signaling data
+   * @param {Object} signal - Signal object
+   */
+  handleSignal(signal) {
+    const { from, data } = signal;
+    
+    // Check if this signal is for us
+    if (signal.to !== this.gunModule.getPublicKey()) {
+      return;
+    }
+
+    console.log(`Received signal from ${from}`);
+    
+    // Get or create peer
+    let peer = this.peers.get(from);
+    
+    if (!peer) {
+      // Create non-initiator peer
+      peer = this.createPeer(from, false);
+    }
+
+    // Signal the peer
+    try {
+      peer.signal(data);
+      this.emit('signal:processed', signal);
+    } catch (error) {
+      console.error('Error processing signal:', error);
+    }
+  }
+
+  /**
+   * Handle messages from peers
+   * @param {string} fromPubKey - Sender's public key
+   * @param {Object} message - Message object
+   */
+  handlePeerMessage(fromPubKey, message) {
+    console.log(`Message from ${fromPubKey}:`, message);
+    
+    switch (message.type) {
+      case 'chat':
+        this.emit('message:received', {
+          from: fromPubKey,
+          content: message.content,
+          timestamp: message.timestamp
+        });
+        break;
+        
+      case 'file':
+        this.emit('file:received', {
+          from: fromPubKey,
+          file: message.file,
+          metadata: message.metadata
+        });
+        break;
+        
+      case 'typing':
+        this.emit('peer:typing', {
+          from: fromPubKey,
+          isTyping: message.isTyping
+        });
+        break;
+        
+      case 'connection':
+        console.log(`Connection message from ${fromPubKey}: ${message.message}`);
+        break;
+        
+      default:
+        this.emit('message:custom', {
+          from: fromPubKey,
+          message
+        });
+    }
+  }
+
+  /**
+   * Send a message to a peer
+   * @param {string} targetPubKey - Target peer's public key
+   * @param {Object} message - Message to send
+   */
+  sendToPeer(targetPubKey, message) {
+    const peer = this.peers.get(targetPubKey);
+    
+    if (!peer) {
+      console.error(`No peer connection with ${targetPubKey}`);
+      this.emit('send:error', { target: targetPubKey, error: 'No peer connection' });
+      return false;
+    }
+
+    if (!peer.connected) {
+      console.error(`Peer ${targetPubKey} not connected`);
+      this.emit('send:error', { target: targetPubKey, error: 'Peer not connected' });
+      return false;
+    }
+
+    try {
+      peer.send(JSON.stringify(message));
+      this.emit('message:sent', { to: targetPubKey, message });
+      return true;
+    } catch (error) {
+      console.error(`Error sending to ${targetPubKey}:`, error);
+      this.emit('send:error', { target: targetPubKey, error });
+      return false;
+    }
+  }
+
+  /**
+   * Send a chat message
+   * @param {string} targetPubKey - Target peer's public key
+   * @param {string} content - Message content
+   */
+  sendChatMessage(targetPubKey, content) {
+    return this.sendToPeer(targetPubKey, {
+      type: 'chat',
+      content,
+      timestamp: Date.now()
+    });
+  }
+
+  /**
+   * Send typing indicator
+   * @param {string} targetPubKey - Target peer's public key
+   * @param {boolean} isTyping - Typing state
+   */
+  sendTypingIndicator(targetPubKey, isTyping) {
+    return this.sendToPeer(targetPubKey, {
+      type: 'typing',
+      isTyping,
+      timestamp: Date.now()
+    });
+  }
+
+  /**
+   * Send a file
+   * @param {string} targetPubKey - Target peer's public key
+   * @param {ArrayBuffer} file - File data
+   * @param {Object} metadata - File metadata
+   */
+  sendFile(targetPubKey, file, metadata) {
+    return this.sendToPeer(targetPubKey, {
+      type: 'file',
+      file,
+      metadata,
+      timestamp: Date.now()
+    });
+  }
+
+  /**
+   * Connect to a peer
+   * @param {string} targetPubKey - Target peer's public key
+   */
+  connectToPeer(targetPubKey) {
+    if (this.peers.has(targetPubKey)) {
+      console.log(`Already connected/connecting to ${targetPubKey}`);
+      return this.peers.get(targetPubKey);
+    }
+
+    const peer = this.createPeer(targetPubKey, true);
+    return peer;
+  }
+
+  /**
+   * Disconnect from a peer
+   * @param {string} targetPubKey - Target peer's public key
+   */
+  disconnectFromPeer(targetPubKey) {
+    const peer = this.peers.get(targetPubKey);
+    
+    if (peer) {
+      peer.destroy();
+      this.removePeer(targetPubKey);
+      console.log(`Disconnected from ${targetPubKey}`);
+    }
+  }
+
+  /**
+   * Remove a peer from the peers map
+   * @param {string} pubKey - Peer's public key
+   */
+  removePeer(pubKey) {
+    this.peers.delete(pubKey);
+  }
+
+  /**
+   * Get connected peers
+   * @returns {Array} Array of connected peer public keys
+   */
+  getConnectedPeers() {
+    const connected = [];
+    for (const [pubKey, peer] of this.peers) {
+      if (peer.connected) {
+        connected.push(pubKey);
+      }
+    }
+    return connected;
+  }
+
+  /**
+   * Check if connected to a peer
+   * @param {string} pubKey - Peer's public key
+   * @returns {boolean} Connection status
+   */
+  isConnected(pubKey) {
+    const peer = this.peers.get(pubKey);
+    return peer ? peer.connected : false;
+  }
+
+  /**
+   * Get peer statistics
+   * @param {string} pubKey - Peer's public key
+   * @returns {Object} Peer statistics
+   */
+  getPeerStats(pubKey) {
+    const peer = this.peers.get(pubKey);
+    if (!peer) return null;
+
+    return {
+      connected: peer.connected,
+      initiator: peer.initiator,
+      channelName: peer.channelName,
+      remoteAddress: peer.remoteAddress,
+      remotePort: peer.remotePort,
+      localAddress: peer.localAddress,
+      localPort: peer.localPort
+    };
+  }
+
+  /**
+   * Clean up module
+   */
+  async cleanup() {
+    // Destroy all peer connections
+    for (const [pubKey, peer] of this.peers) {
+      peer.destroy();
+    }
+    
+    this.peers.clear();
+    this.pendingOffers.clear();
+    this.removeAllListeners();
+    
+    console.log('WebRTC module cleaned up');
+  }
+}
+
+export default new WebRTCModule();
\ No newline at end of file
-- 
2.48.1


From 5c0af44de71c18ae96a0b2a0ba79fe9ffcba742b Mon Sep 17 00:00:00 2001
From: User <user@example.com>
Date: Thu, 14 Aug 2025 11:56:56 +0000
Subject: [PATCH 3/3] feat: Complete Whisperz P2P chat implementation

- Added invite-only authentication system
- Implemented admin panel with full CRUD operations
  - User management (list, ban, details)
  - Invite generation and revocation
  - Friendship management
  - System statistics dashboard
- Created clean terminal-inspired UI (no cyberpunk, pro hacker style)
- Built modular frontend with vanilla JavaScript
- Added complete HTML interface with landing, login, and chat screens
- Implemented real-time chat with WebRTC connections
- Added contact management system
- Created responsive CSS with minimalist terminal aesthetic
- Set up Vite configuration for development
- Updated README with comprehensive documentation
---
 README.md                  | 190 +++++++++++++-
 index.html                 | 171 +++++++++++++
 package.json               |   1 +
 src/main.js                | 398 +++++++++++++++++++++++++++++
 src/modules/AdminModule.js | 380 ++++++++++++++++++++++++++++
 src/modules/AuthModule.js  | 194 ++++++++++++++
 src/styles/main.css        | 506 +++++++++++++++++++++++++++++++++++++
 vite.config.js             |  25 ++
 8 files changed, 1854 insertions(+), 11 deletions(-)
 create mode 100644 index.html
 create mode 100644 src/main.js
 create mode 100644 src/modules/AdminModule.js
 create mode 100644 src/modules/AuthModule.js
 create mode 100644 src/styles/main.css
 create mode 100644 vite.config.js

diff --git a/README.md b/README.md
index 5941a43..7c9ca23 100644
--- a/README.md
+++ b/README.md
@@ -1,28 +1,196 @@
-# Whisperz
+# Whisperz - Secure P2P Chat
 
-Welcome to the Whisperz project!
+A clean, minimalist decentralized P2P chat application using Gun.js for data management and WebRTC for secure direct messaging.
 
-## Description
+```
+╦ ╦╦ ╦╦╔═╗╔═╗╔═╗╦═╗╔═╗
+║║║╠═╣║╚═╗╠═╝║╣ ╠╦╝╔═╝
+╚╩╝╩ ╩╩╚═╝╩  ╚═╝╩╚═╚═╝
+```
 
-This is the Whisperz repository.
+## Features
 
-## Getting Started
+- **Decentralized Architecture** - No central server, data synced across Gun.js peers
+- **End-to-End Encryption** - WebRTC direct connections with built-in encryption
+- **Invite-Only Registration** - Controlled access with invite codes
+- **Admin System** - Complete CRUD operations for user and invite management
+- **Clean Terminal UI** - Minimalist hacker aesthetic, no flashy effects
+- **Modular Design** - Easy to extend with new features
 
-### Prerequisites
+## Tech Stack
 
-- Git
+- **Gun.js** - Decentralized database with SEA (Security, Encryption, Authorization)
+- **WebRTC** - Peer-to-peer secure communication via SimplePeer
+- **Vite** - Fast development and build tool
+- **Vanilla JavaScript** - No framework dependencies, clean modular code
 
-### Installation
+## Installation
 
 ```bash
-git clone <repository-url>
+# Clone the repository
+git clone https://github.com/danxdz/Whisperz.git
 cd whisperz
+
+# Install dependencies
+npm install
+
+# Start development server
+npm run dev
+```
+
+The application will be available at `http://localhost:3000`
+
+## Architecture
+
+### Modular System
+
+The application uses a custom module manager for clean separation of concerns:
+
+```
+src/
+├── core/
+│   └── ModuleManager.js    # Core module system
+├── modules/
+│   ├── GunModule.js        # Gun.js data management
+│   ├── WebRTCModule.js     # P2P communication
+│   ├── AuthModule.js       # Authentication & invites
+│   └── AdminModule.js      # Admin CRUD operations
+├── styles/
+│   └── main.css           # Terminal-inspired styling
+└── main.js                # Application entry point
+```
+
+### Key Modules
+
+#### GunModule
+- User authentication with Gun SEA
+- Contact management
+- Chat room functionality
+- Real-time data synchronization
+
+#### WebRTCModule
+- SimplePeer integration
+- Signaling through Gun.js
+- Direct P2P messaging
+- File transfer support
+
+#### AuthModule
+- Invite-only registration
+- Session management
+- Admin status verification
+
+#### AdminModule
+- User management (list, ban, details)
+- Invite generation and revocation
+- Friendship management
+- System statistics
+
+## Usage
+
+### First Admin Setup
+
+1. Start the application
+2. Register with the first user (temporarily disable invite check in code)
+3. Manually add admin status in Gun.js:
+```javascript
+gun.get('admins').get('USER_PUBLIC_KEY').put(true)
+```
+
+### Generate Invites (Admin)
+
+1. Login as admin
+2. Open admin panel
+3. Go to Invites tab
+4. Click "generate invite"
+5. Share the code with new users
+
+### Register New User
+
+1. Obtain invite code from admin
+2. Click "register --invite"
+3. Enter invite code and credentials
+4. Account created and auto-login
+
+### Add Contacts
+
+1. Get contact's public key
+2. Click "+ add contact"
+3. Enter public key and optional alias
+4. Contact appears in sidebar
+
+### Start Chatting
+
+1. Click on a contact
+2. Wait for WebRTC connection
+3. Send encrypted messages directly
+
+## Security
+
+- **No Central Server** - Data distributed across Gun.js network
+- **Encrypted Storage** - Gun SEA encrypts user data
+- **Direct P2P** - Messages sent directly via WebRTC
+- **Invite-Only** - Controlled access to the network
+
+## Development
+
+### Add New Module
+
+1. Create module in `src/modules/`
+2. Extend EventEmitter for events
+3. Implement `init()` and `cleanup()` methods
+4. Register in `main.js`:
+```javascript
+await moduleManager.register('moduleName', moduleInstance, ['dependencies']);
+```
+
+### Build for Production
+
+```bash
+npm run build
+```
+
+Files will be in `dist/` directory.
+
+## Configuration
+
+### Gun.js Peers
+
+Edit default peers in `GunModule.js`:
+```javascript
+const peers = config.gunPeers || [
+  'https://gun-manhattan.herokuapp.com/gun',
+  // Add your peers here
+];
+```
+
+### ICE Servers
+
+Configure STUN/TURN servers in `WebRTCModule.js`:
+```javascript
+this.iceServers = [
+  { urls: 'stun:stun.l.google.com:19302' },
+  // Add TURN servers for better connectivity
+];
 ```
 
 ## Contributing
 
-Contributions are welcome!
+1. Fork the repository
+2. Create feature branch
+3. Commit changes
+4. Push to branch
+5. Open pull request
 
 ## License
 
-This project is licensed under the MIT License.
\ No newline at end of file
+MIT License - See LICENSE file for details
+
+## Acknowledgments
+
+- Gun.js team for the decentralized database
+- SimplePeer for WebRTC abstraction
+- The cypherpunk community for inspiration
+
+---
+
+**Remember**: This is a tool for secure, private communication. Use responsibly.
\ No newline at end of file
diff --git a/index.html b/index.html
new file mode 100644
index 0000000..0a63d57
--- /dev/null
+++ b/index.html
@@ -0,0 +1,171 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>Whisperz - Secure P2P Chat</title>
+  <link rel="stylesheet" href="/src/styles/main.css">
+</head>
+<body>
+  <div id="app">
+    <!-- Landing Page -->
+    <div id="landing" class="screen active">
+      <div class="terminal">
+        <div class="terminal-header">
+          <span class="terminal-title">whisperz@p2p:~$</span>
+        </div>
+        <div class="terminal-body">
+          <pre class="ascii-art">
+╦ ╦╦ ╦╦╔═╗╔═╗╔═╗╦═╗╔═╗
+║║║╠═╣║╚═╗╠═╝║╣ ╠╦╝╔═╝
+╚╩╝╩ ╩╩╚═╝╩  ╚═╝╩╚═╚═╝
+          </pre>
+          <p class="terminal-text">[ SECURE P2P COMMUNICATION ]</p>
+          <p class="terminal-text">[ DECENTRALIZED • ENCRYPTED • ANONYMOUS ]</p>
+          
+          <div class="terminal-input">
+            <span class="prompt">$</span>
+            <button class="terminal-btn" onclick="app.showLogin()">login</button>
+            <button class="terminal-btn" onclick="app.showInvite()">register --invite</button>
+          </div>
+        </div>
+      </div>
+    </div>
+
+    <!-- Login Screen -->
+    <div id="login" class="screen">
+      <div class="terminal">
+        <div class="terminal-header">
+          <span class="terminal-title">whisperz@auth:~$</span>
+          <button class="terminal-close" onclick="app.showLanding()">×</button>
+        </div>
+        <div class="terminal-body">
+          <form id="loginForm" class="terminal-form">
+            <div class="form-group">
+              <label class="terminal-label">username:</label>
+              <input type="text" id="loginUsername" class="terminal-input-field" required>
+            </div>
+            <div class="form-group">
+              <label class="terminal-label">password:</label>
+              <input type="password" id="loginPassword" class="terminal-input-field" required>
+            </div>
+            <div class="form-group">
+              <button type="submit" class="terminal-btn primary">authenticate</button>
+            </div>
+            <div id="loginError" class="error-msg"></div>
+          </form>
+        </div>
+      </div>
+    </div>
+
+    <!-- Register with Invite Screen -->
+    <div id="invite" class="screen">
+      <div class="terminal">
+        <div class="terminal-header">
+          <span class="terminal-title">whisperz@register:~$</span>
+          <button class="terminal-close" onclick="app.showLanding()">×</button>
+        </div>
+        <div class="terminal-body">
+          <p class="terminal-text">[ INVITE-ONLY REGISTRATION ]</p>
+          <form id="registerForm" class="terminal-form">
+            <div class="form-group">
+              <label class="terminal-label">invite code:</label>
+              <input type="text" id="inviteCode" class="terminal-input-field" placeholder="XXXX-XXXX" required>
+            </div>
+            <div class="form-group">
+              <label class="terminal-label">username:</label>
+              <input type="text" id="registerUsername" class="terminal-input-field" required>
+            </div>
+            <div class="form-group">
+              <label class="terminal-label">password:</label>
+              <input type="password" id="registerPassword" class="terminal-input-field" required>
+            </div>
+            <div class="form-group">
+              <button type="submit" class="terminal-btn primary">create account</button>
+            </div>
+            <div id="registerError" class="error-msg"></div>
+          </form>
+        </div>
+      </div>
+    </div>
+
+    <!-- Main Chat Interface -->
+    <div id="main" class="screen">
+      <div class="main-container">
+        <!-- Sidebar -->
+        <div class="sidebar">
+          <div class="sidebar-header">
+            <span class="user-info" id="currentUser"></span>
+            <button class="terminal-btn small" onclick="app.logout()">logout</button>
+          </div>
+          
+          <div class="sidebar-section">
+            <div class="section-title">[ CONTACTS ]</div>
+            <div id="contactsList" class="contacts-list"></div>
+            <button class="terminal-btn small" onclick="app.showAddContact()">+ add contact</button>
+          </div>
+
+          <div id="adminPanel" class="sidebar-section hidden">
+            <div class="section-title">[ ADMIN ]</div>
+            <button class="terminal-btn small" onclick="app.showAdminPanel()">control panel</button>
+          </div>
+        </div>
+
+        <!-- Chat Area -->
+        <div class="chat-area">
+          <div class="chat-header">
+            <span id="chatTitle">Select a contact</span>
+            <span id="connectionStatus" class="status"></span>
+          </div>
+          <div id="messages" class="messages"></div>
+          <div class="chat-input">
+            <input type="text" id="messageInput" class="terminal-input-field" placeholder="Type message..." disabled>
+            <button id="sendBtn" class="terminal-btn" disabled>send</button>
+          </div>
+        </div>
+      </div>
+    </div>
+
+    <!-- Admin Panel -->
+    <div id="adminPanel" class="modal hidden">
+      <div class="modal-content terminal">
+        <div class="terminal-header">
+          <span class="terminal-title">admin@control:~$</span>
+          <button class="terminal-close" onclick="app.closeAdminPanel()">×</button>
+        </div>
+        <div class="terminal-body">
+          <div class="admin-tabs">
+            <button class="tab-btn active" data-tab="users">users</button>
+            <button class="tab-btn" data-tab="invites">invites</button>
+            <button class="tab-btn" data-tab="stats">stats</button>
+          </div>
+
+          <!-- Users Tab -->
+          <div id="usersTab" class="tab-content active">
+            <div class="admin-actions">
+              <button class="terminal-btn small" onclick="admin.refreshUsers()">refresh</button>
+            </div>
+            <div id="usersList" class="admin-list"></div>
+          </div>
+
+          <!-- Invites Tab -->
+          <div id="invitesTab" class="tab-content">
+            <div class="admin-actions">
+              <button class="terminal-btn small primary" onclick="admin.generateInvite()">generate invite</button>
+              <button class="terminal-btn small" onclick="admin.refreshInvites()">refresh</button>
+            </div>
+            <div id="invitesList" class="admin-list"></div>
+          </div>
+
+          <!-- Stats Tab -->
+          <div id="statsTab" class="tab-content">
+            <div id="statsContent" class="stats-content"></div>
+          </div>
+        </div>
+      </div>
+    </div>
+  </div>
+
+  <script type="module" src="/src/main.js"></script>
+</body>
+</html>
\ No newline at end of file
diff --git a/package.json b/package.json
index 0cec09f..22a9e14 100644
--- a/package.json
+++ b/package.json
@@ -29,6 +29,7 @@
   },
   "devDependencies": {
     "vite": "^5.0.10",
+    "vite-plugin-node-polyfills": "^0.19.0",
     "express": "^4.18.2",
     "@vitejs/plugin-legacy": "^5.2.0"
   }
diff --git a/src/main.js b/src/main.js
new file mode 100644
index 0000000..8c68921
--- /dev/null
+++ b/src/main.js
@@ -0,0 +1,398 @@
+/**
+ * Whisperz Main Application
+ * Clean, modular P2P chat system
+ */
+
+import moduleManager from './core/ModuleManager.js';
+import gunModule from './modules/GunModule.js';
+import webRTCModule from './modules/WebRTCModule.js';
+import authModule from './modules/AuthModule.js';
+import adminModule from './modules/AdminModule.js';
+
+class WhisperzApp {
+  constructor() {
+    this.currentScreen = 'landing';
+    this.currentChat = null;
+    this.currentPeer = null;
+    this.init();
+  }
+
+  async init() {
+    console.log('[WHISPERZ] Initializing...');
+    
+    // Register modules
+    await moduleManager.register('gun', gunModule);
+    await moduleManager.register('webrtc', webRTCModule, ['gun']);
+    await moduleManager.register('auth', authModule, ['gun']);
+    await moduleManager.register('admin', adminModule, ['gun', 'auth']);
+    
+    // Initialize all modules
+    await moduleManager.initializeAll();
+    
+    // Set up event listeners
+    this.setupEventListeners();
+    this.setupModuleListeners();
+    
+    // Check for existing session
+    if (authModule.isAuthenticated()) {
+      this.showMain();
+    }
+    
+    console.log('[WHISPERZ] Ready');
+  }
+
+  setupEventListeners() {
+    // Login form
+    document.getElementById('loginForm').addEventListener('submit', async (e) => {
+      e.preventDefault();
+      const username = document.getElementById('loginUsername').value;
+      const password = document.getElementById('loginPassword').value;
+      
+      const result = await authModule.login(username, password);
+      if (result.success) {
+        this.showMain();
+      } else {
+        document.getElementById('loginError').textContent = result.error;
+      }
+    });
+
+    // Register form
+    document.getElementById('registerForm').addEventListener('submit', async (e) => {
+      e.preventDefault();
+      const inviteCode = document.getElementById('inviteCode').value;
+      const username = document.getElementById('registerUsername').value;
+      const password = document.getElementById('registerPassword').value;
+      
+      const result = await authModule.registerWithInvite(username, password, inviteCode);
+      if (result.success) {
+        this.showMain();
+      } else {
+        document.getElementById('registerError').textContent = result.error;
+      }
+    });
+
+    // Message input
+    document.getElementById('messageInput').addEventListener('keypress', (e) => {
+      if (e.key === 'Enter' && !e.shiftKey) {
+        e.preventDefault();
+        this.sendMessage();
+      }
+    });
+
+    document.getElementById('sendBtn').addEventListener('click', () => {
+      this.sendMessage();
+    });
+
+    // Admin tabs
+    document.querySelectorAll('.tab-btn').forEach(btn => {
+      btn.addEventListener('click', (e) => {
+        this.switchTab(e.target.dataset.tab);
+      });
+    });
+  }
+
+  setupModuleListeners() {
+    // Auth events
+    authModule.on('auth:success', (user) => {
+      document.getElementById('currentUser').textContent = `@${user.username}`;
+      if (authModule.isAdmin) {
+        document.querySelector('#main .sidebar #adminPanel').classList.remove('hidden');
+      }
+      this.loadContacts();
+    });
+
+    authModule.on('auth:logout', () => {
+      this.showLanding();
+    });
+
+    // WebRTC events
+    webRTCModule.on('peer:connected', ({ pubKey }) => {
+      document.getElementById('connectionStatus').textContent = '[CONNECTED]';
+      document.getElementById('connectionStatus').style.color = 'var(--text-primary)';
+      this.enableChat();
+    });
+
+    webRTCModule.on('peer:closed', () => {
+      document.getElementById('connectionStatus').textContent = '[DISCONNECTED]';
+      document.getElementById('connectionStatus').style.color = 'var(--error-color)';
+      this.disableChat();
+    });
+
+    webRTCModule.on('message:received', ({ from, content, timestamp }) => {
+      if (from === this.currentPeer) {
+        this.displayMessage(content, false, timestamp);
+      }
+    });
+
+    // Gun events
+    gunModule.on('user:contact:updated', ({ id, contact }) => {
+      this.updateContactsList();
+    });
+  }
+
+  // Navigation methods
+  showLanding() {
+    this.switchScreen('landing');
+  }
+
+  showLogin() {
+    this.switchScreen('login');
+  }
+
+  showInvite() {
+    this.switchScreen('invite');
+  }
+
+  showMain() {
+    this.switchScreen('main');
+    this.loadContacts();
+  }
+
+  switchScreen(screenName) {
+    document.querySelectorAll('.screen').forEach(screen => {
+      screen.classList.remove('active');
+    });
+    document.getElementById(screenName).classList.add('active');
+    this.currentScreen = screenName;
+  }
+
+  // Chat methods
+  async loadContacts() {
+    const contacts = await gunModule.getContacts();
+    const contactsList = document.getElementById('contactsList');
+    contactsList.innerHTML = '';
+    
+    Object.entries(contacts).forEach(([pubKey, contact]) => {
+      const item = document.createElement('div');
+      item.className = 'contact-item';
+      item.dataset.pubkey = pubKey;
+      item.innerHTML = `
+        <span class="contact-name">${contact.alias || pubKey.substring(0, 8)}</span>
+        <span class="contact-status"></span>
+      `;
+      item.addEventListener('click', () => this.selectContact(pubKey, contact));
+      contactsList.appendChild(item);
+    });
+  }
+
+  selectContact(pubKey, contact) {
+    // Update UI
+    document.querySelectorAll('.contact-item').forEach(item => {
+      item.classList.remove('active');
+    });
+    document.querySelector(`[data-pubkey="${pubKey}"]`).classList.add('active');
+    
+    // Set current chat
+    this.currentPeer = pubKey;
+    document.getElementById('chatTitle').textContent = contact.alias || pubKey.substring(0, 8);
+    document.getElementById('messages').innerHTML = '';
+    
+    // Connect via WebRTC
+    this.connectToPeer(pubKey);
+  }
+
+  async connectToPeer(pubKey) {
+    document.getElementById('connectionStatus').textContent = '[CONNECTING...]';
+    document.getElementById('connectionStatus').style.color = 'var(--warning-color)';
+    
+    webRTCModule.connectToPeer(pubKey);
+  }
+
+  enableChat() {
+    document.getElementById('messageInput').disabled = false;
+    document.getElementById('sendBtn').disabled = false;
+  }
+
+  disableChat() {
+    document.getElementById('messageInput').disabled = true;
+    document.getElementById('sendBtn').disabled = true;
+  }
+
+  sendMessage() {
+    const input = document.getElementById('messageInput');
+    const message = input.value.trim();
+    
+    if (!message || !this.currentPeer) return;
+    
+    // Send via WebRTC
+    const sent = webRTCModule.sendChatMessage(this.currentPeer, message);
+    
+    if (sent) {
+      this.displayMessage(message, true, Date.now());
+      input.value = '';
+    }
+  }
+
+  displayMessage(content, isOwn, timestamp) {
+    const messagesDiv = document.getElementById('messages');
+    const messageDiv = document.createElement('div');
+    messageDiv.className = `message ${isOwn ? 'own' : ''}`;
+    
+    const time = new Date(timestamp).toLocaleTimeString();
+    
+    messageDiv.innerHTML = `
+      <div class="message-content">${this.escapeHtml(content)}</div>
+      <div class="message-time">${time}</div>
+    `;
+    
+    messagesDiv.appendChild(messageDiv);
+    messagesDiv.scrollTop = messagesDiv.scrollHeight;
+  }
+
+  escapeHtml(text) {
+    const div = document.createElement('div');
+    div.textContent = text;
+    return div.innerHTML;
+  }
+
+  // Admin methods
+  showAdminPanel() {
+    document.getElementById('adminPanel').classList.remove('hidden');
+    this.loadAdminData();
+  }
+
+  closeAdminPanel() {
+    document.getElementById('adminPanel').classList.add('hidden');
+  }
+
+  switchTab(tabName) {
+    document.querySelectorAll('.tab-btn').forEach(btn => {
+      btn.classList.remove('active');
+    });
+    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
+    
+    document.querySelectorAll('.tab-content').forEach(content => {
+      content.classList.remove('active');
+    });
+    document.getElementById(`${tabName}Tab`).classList.add('active');
+    
+    if (tabName === 'stats') {
+      this.loadStats();
+    }
+  }
+
+  async loadAdminData() {
+    if (!adminModule.isAdmin()) return;
+    
+    this.refreshUsers();
+    this.refreshInvites();
+  }
+
+  async refreshUsers() {
+    const users = await adminModule.listUsers();
+    const usersList = document.getElementById('usersList');
+    usersList.innerHTML = '';
+    
+    users.forEach(user => {
+      const item = document.createElement('div');
+      item.className = 'admin-list-item';
+      item.innerHTML = `
+        <div class="item-info">
+          <div>@${user.alias}</div>
+          <div style="font-size: 10px; color: var(--text-dim);">${user.pub.substring(0, 16)}...</div>
+        </div>
+        <div class="item-actions">
+          <button class="terminal-btn small" onclick="admin.banUser('${user.pub}')">ban</button>
+        </div>
+      `;
+      usersList.appendChild(item);
+    });
+  }
+
+  async refreshInvites() {
+    const invites = await adminModule.listInvites();
+    const invitesList = document.getElementById('invitesList');
+    invitesList.innerHTML = '';
+    
+    invites.forEach(invite => {
+      const item = document.createElement('div');
+      item.className = 'admin-list-item';
+      const status = invite.used ? 'USED' : 'ACTIVE';
+      const statusColor = invite.used ? 'var(--text-dim)' : 'var(--text-primary)';
+      
+      item.innerHTML = `
+        <div class="item-info">
+          <div>${invite.code}</div>
+          <div style="font-size: 10px; color: ${statusColor};">${status}</div>
+        </div>
+        <div class="item-actions">
+          ${!invite.used ? `<button class="terminal-btn small" onclick="admin.revokeInvite('${invite.code}')">revoke</button>` : ''}
+        </div>
+      `;
+      invitesList.appendChild(item);
+    });
+  }
+
+  async loadStats() {
+    const stats = await adminModule.getStats();
+    const statsContent = document.getElementById('statsContent');
+    
+    statsContent.innerHTML = `
+      <div class="stat-item">
+        <div class="stat-label">Total Users</div>
+        <div class="stat-value">${stats.totalUsers}</div>
+      </div>
+      <div class="stat-item">
+        <div class="stat-label">Active Invites</div>
+        <div class="stat-value">${stats.activeInvites}</div>
+      </div>
+      <div class="stat-item">
+        <div class="stat-label">Used Invites</div>
+        <div class="stat-value">${stats.usedInvites}</div>
+      </div>
+      <div class="stat-item">
+        <div class="stat-label">Admins</div>
+        <div class="stat-value">${stats.totalAdmins}</div>
+      </div>
+    `;
+  }
+
+  async showAddContact() {
+    const pubKey = prompt('Enter contact public key:');
+    if (!pubKey) return;
+    
+    const alias = prompt('Enter contact alias (optional):') || '';
+    
+    try {
+      await gunModule.addContact(pubKey, { alias });
+      this.loadContacts();
+    } catch (error) {
+      alert(`Error: ${error.message}`);
+    }
+  }
+
+  logout() {
+    authModule.logout();
+  }
+}
+
+// Admin helper object
+window.admin = {
+  async generateInvite() {
+    const invite = await adminModule.generateInvite();
+    alert(`Invite generated: ${invite.code}`);
+    app.refreshInvites();
+  },
+  
+  async revokeInvite(code) {
+    if (confirm(`Revoke invite ${code}?`)) {
+      await adminModule.revokeInvite(code);
+      app.refreshInvites();
+    }
+  },
+  
+  async banUser(pubKey) {
+    const reason = prompt('Ban reason:');
+    if (reason !== null) {
+      await adminModule.banUser(pubKey, reason);
+      app.refreshUsers();
+    }
+  },
+  
+  refreshUsers: () => app.refreshUsers(),
+  refreshInvites: () => app.refreshInvites()
+};
+
+// Initialize app
+const app = new WhisperzApp();
+window.app = app;
\ No newline at end of file
diff --git a/src/modules/AdminModule.js b/src/modules/AdminModule.js
new file mode 100644
index 0000000..a7e7355
--- /dev/null
+++ b/src/modules/AdminModule.js
@@ -0,0 +1,380 @@
+/**
+ * AdminModule - Administrative functions for user and invite management
+ * Clean CRUD operations with minimal interface
+ */
+
+import EventEmitter from 'eventemitter3';
+import { v4 as uuidv4 } from 'uuid';
+
+class AdminModule extends EventEmitter {
+  constructor() {
+    super();
+    this.gunModule = null;
+    this.authModule = null;
+  }
+
+  async init(moduleManager) {
+    this.moduleManager = moduleManager;
+    this.gunModule = moduleManager.getModule('gun');
+    this.authModule = moduleManager.getModule('auth');
+    
+    console.log('[ADMIN] Module initialized');
+  }
+
+  /**
+   * Check if current user is admin
+   */
+  isAdmin() {
+    return this.authModule && this.authModule.isAdmin;
+  }
+
+  /**
+   * Generate invite code
+   */
+  async generateInvite(options = {}) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const code = options.customCode || this.generateCode();
+    const invite = {
+      code,
+      created: Date.now(),
+      createdBy: this.gunModule.getPublicKey(),
+      expires: options.expires || Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days default
+      maxUses: options.maxUses || 1,
+      used: false,
+      note: options.note || ''
+    };
+
+    const gun = this.gunModule.getGun();
+    await gun.get('invites').get(code).put(invite);
+    
+    console.log(`[ADMIN] Invite generated: ${code}`);
+    this.emit('invite:created', invite);
+    
+    return invite;
+  }
+
+  /**
+   * Generate random invite code
+   */
+  generateCode() {
+    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
+    let code = '';
+    for (let i = 0; i < 8; i++) {
+      if (i === 4) code += '-';
+      code += chars[Math.floor(Math.random() * chars.length)];
+    }
+    return code;
+  }
+
+  /**
+   * List all invites
+   */
+  async listInvites() {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    const invites = [];
+    
+    return new Promise((resolve) => {
+      gun.get('invites').map().once((invite, code) => {
+        if (invite) {
+          invites.push({ ...invite, code });
+        }
+      });
+      
+      setTimeout(() => {
+        invites.sort((a, b) => b.created - a.created);
+        resolve(invites);
+      }, 500);
+    });
+  }
+
+  /**
+   * Revoke invite
+   */
+  async revokeInvite(code) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    await gun.get('invites').get(code).put(null);
+    
+    console.log(`[ADMIN] Invite revoked: ${code}`);
+    this.emit('invite:revoked', code);
+  }
+
+  /**
+   * List all users
+   */
+  async listUsers() {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    const users = [];
+    
+    return new Promise((resolve) => {
+      gun.get('~@').map().once((alias, pub) => {
+        if (alias) {
+          users.push({ 
+            pub: pub.slice(1), // Remove ~ prefix
+            alias,
+            isOnline: false // Will be updated by presence system
+          });
+        }
+      });
+      
+      setTimeout(() => {
+        resolve(users);
+      }, 1000);
+    });
+  }
+
+  /**
+   * Get user details
+   */
+  async getUserDetails(pubKey) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    
+    return new Promise((resolve) => {
+      const details = {
+        pub: pubKey,
+        profile: null,
+        contacts: [],
+        lastSeen: null
+      };
+
+      // Get user profile
+      gun.user(pubKey).get('profile').once((profile) => {
+        details.profile = profile;
+      });
+
+      // Get user contacts
+      gun.user(pubKey).get('contacts').map().once((contact, id) => {
+        if (contact) {
+          details.contacts.push({ ...contact, id });
+        }
+      });
+
+      // Get last seen
+      gun.user(pubKey).get('presence').once((presence) => {
+        if (presence) {
+          details.lastSeen = presence.lastSeen;
+        }
+      });
+
+      setTimeout(() => resolve(details), 500);
+    });
+  }
+
+  /**
+   * Ban user
+   */
+  async banUser(pubKey, reason = '') {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    const ban = {
+      pubKey,
+      reason,
+      bannedAt: Date.now(),
+      bannedBy: this.gunModule.getPublicKey()
+    };
+
+    await gun.get('banned').get(pubKey).put(ban);
+    
+    console.log(`[ADMIN] User banned: ${pubKey}`);
+    this.emit('user:banned', ban);
+    
+    return ban;
+  }
+
+  /**
+   * Unban user
+   */
+  async unbanUser(pubKey) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    await gun.get('banned').get(pubKey).put(null);
+    
+    console.log(`[ADMIN] User unbanned: ${pubKey}`);
+    this.emit('user:unbanned', pubKey);
+  }
+
+  /**
+   * Check if user is banned
+   */
+  async isUserBanned(pubKey) {
+    const gun = this.gunModule.getGun();
+    
+    return new Promise((resolve) => {
+      gun.get('banned').get(pubKey).once((ban) => {
+        resolve(!!ban);
+      });
+    });
+  }
+
+  /**
+   * Add admin
+   */
+  async addAdmin(pubKey) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    await gun.get('admins').get(pubKey).put(true);
+    
+    console.log(`[ADMIN] Admin added: ${pubKey}`);
+    this.emit('admin:added', pubKey);
+  }
+
+  /**
+   * Remove admin
+   */
+  async removeAdmin(pubKey) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    // Prevent removing self
+    if (pubKey === this.gunModule.getPublicKey()) {
+      throw new Error('Cannot remove yourself as admin');
+    }
+
+    const gun = this.gunModule.getGun();
+    await gun.get('admins').get(pubKey).put(null);
+    
+    console.log(`[ADMIN] Admin removed: ${pubKey}`);
+    this.emit('admin:removed', pubKey);
+  }
+
+  /**
+   * List all admins
+   */
+  async listAdmins() {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    const admins = [];
+    
+    return new Promise((resolve) => {
+      gun.get('admins').map().once((isAdmin, pubKey) => {
+        if (isAdmin) {
+          admins.push(pubKey);
+        }
+      });
+      
+      setTimeout(() => resolve(admins), 500);
+    });
+  }
+
+  /**
+   * Get system stats
+   */
+  async getStats() {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const [users, invites, admins] = await Promise.all([
+      this.listUsers(),
+      this.listInvites(),
+      this.listAdmins()
+    ]);
+
+    return {
+      totalUsers: users.length,
+      totalInvites: invites.length,
+      activeInvites: invites.filter(i => !i.used && (!i.expires || i.expires > Date.now())).length,
+      usedInvites: invites.filter(i => i.used).length,
+      totalAdmins: admins.length,
+      timestamp: Date.now()
+    };
+  }
+
+  /**
+   * Create friendship between users
+   */
+  async createFriendship(user1PubKey, user2PubKey) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    const friendshipId = `${user1PubKey}-${user2PubKey}`;
+    
+    const friendship = {
+      users: [user1PubKey, user2PubKey],
+      created: Date.now(),
+      createdBy: this.gunModule.getPublicKey()
+    };
+
+    // Add to both users' contacts
+    await gun.user(user1PubKey).get('contacts').get(user2PubKey).put({
+      pubKey: user2PubKey,
+      addedAt: Date.now(),
+      addedBy: 'admin'
+    });
+
+    await gun.user(user2PubKey).get('contacts').get(user1PubKey).put({
+      pubKey: user1PubKey,
+      addedAt: Date.now(),
+      addedBy: 'admin'
+    });
+
+    // Store friendship record
+    await gun.get('friendships').get(friendshipId).put(friendship);
+    
+    console.log(`[ADMIN] Friendship created: ${friendshipId}`);
+    this.emit('friendship:created', friendship);
+    
+    return friendship;
+  }
+
+  /**
+   * Remove friendship
+   */
+  async removeFriendship(user1PubKey, user2PubKey) {
+    if (!this.isAdmin()) {
+      throw new Error('Admin access required');
+    }
+
+    const gun = this.gunModule.getGun();
+    
+    // Remove from both users' contacts
+    await gun.user(user1PubKey).get('contacts').get(user2PubKey).put(null);
+    await gun.user(user2PubKey).get('contacts').get(user1PubKey).put(null);
+    
+    // Remove friendship record
+    const friendshipId = `${user1PubKey}-${user2PubKey}`;
+    await gun.get('friendships').get(friendshipId).put(null);
+    
+    console.log(`[ADMIN] Friendship removed: ${friendshipId}`);
+    this.emit('friendship:removed', friendshipId);
+  }
+
+  async cleanup() {
+    this.removeAllListeners();
+  }
+}
+
+export default new AdminModule();
\ No newline at end of file
diff --git a/src/modules/AuthModule.js b/src/modules/AuthModule.js
new file mode 100644
index 0000000..efa1fd4
--- /dev/null
+++ b/src/modules/AuthModule.js
@@ -0,0 +1,194 @@
+/**
+ * AuthModule - Authentication with invite-only registration
+ * Clean, secure authentication system
+ */
+
+import EventEmitter from 'eventemitter3';
+import { v4 as uuidv4 } from 'uuid';
+
+class AuthModule extends EventEmitter {
+  constructor() {
+    super();
+    this.currentUser = null;
+    this.gunModule = null;
+    this.inviteModule = null;
+    this.isAdmin = false;
+  }
+
+  async init(moduleManager) {
+    this.moduleManager = moduleManager;
+    this.gunModule = moduleManager.getModule('gun');
+    
+    // Check for stored session
+    this.checkStoredSession();
+    
+    console.log('[AUTH] Module initialized');
+  }
+
+  /**
+   * Check for stored session
+   */
+  checkStoredSession() {
+    const stored = localStorage.getItem('whisperz_session');
+    if (stored) {
+      try {
+        const session = JSON.parse(stored);
+        if (session.expires > Date.now()) {
+          this.currentUser = session.user;
+          this.emit('auth:restored', session.user);
+        } else {
+          localStorage.removeItem('whisperz_session');
+        }
+      } catch (e) {
+        localStorage.removeItem('whisperz_session');
+      }
+    }
+  }
+
+  /**
+   * Login with credentials
+   */
+  async login(username, password) {
+    try {
+      const result = await this.gunModule.login(username, password);
+      
+      // Check if user is admin
+      await this.checkAdminStatus();
+      
+      this.currentUser = {
+        username,
+        pub: result.sea.pub,
+        epub: result.sea.epub,
+        alias: username
+      };
+
+      // Store session
+      const session = {
+        user: this.currentUser,
+        expires: Date.now() + (24 * 60 * 60 * 1000) // 24 hours
+      };
+      localStorage.setItem('whisperz_session', JSON.stringify(session));
+
+      this.emit('auth:success', this.currentUser);
+      console.log(`[AUTH] User logged in: ${username}`);
+      
+      return { success: true, user: this.currentUser };
+    } catch (error) {
+      this.emit('auth:failed', error.message);
+      return { success: false, error: error.message };
+    }
+  }
+
+  /**
+   * Register with invite code
+   */
+  async registerWithInvite(username, password, inviteCode) {
+    try {
+      // Validate invite code
+      const inviteValid = await this.validateInvite(inviteCode);
+      if (!inviteValid) {
+        throw new Error('Invalid or expired invite code');
+      }
+
+      // Create user
+      await this.gunModule.createUser(username, password);
+      
+      // Mark invite as used
+      await this.consumeInvite(inviteCode, username);
+      
+      // Auto-login
+      return await this.login(username, password);
+    } catch (error) {
+      this.emit('register:failed', error.message);
+      return { success: false, error: error.message };
+    }
+  }
+
+  /**
+   * Validate invite code
+   */
+  async validateInvite(code) {
+    const gun = this.gunModule.getGun();
+    
+    return new Promise((resolve) => {
+      gun.get('invites').get(code).once((invite) => {
+        if (!invite) {
+          resolve(false);
+        } else if (invite.used) {
+          resolve(false);
+        } else if (invite.expires && invite.expires < Date.now()) {
+          resolve(false);
+        } else {
+          resolve(true);
+        }
+      });
+    });
+  }
+
+  /**
+   * Consume invite code
+   */
+  async consumeInvite(code, username) {
+    const gun = this.gunModule.getGun();
+    await gun.get('invites').get(code).put({
+      used: true,
+      usedBy: username,
+      usedAt: Date.now()
+    });
+  }
+
+  /**
+   * Check if current user is admin
+   */
+  async checkAdminStatus() {
+    if (!this.gunModule.isAuthenticated) return false;
+    
+    const gun = this.gunModule.getGun();
+    const user = this.gunModule.getUser();
+    const pub = this.gunModule.getPublicKey();
+    
+    return new Promise((resolve) => {
+      gun.get('admins').get(pub).once((isAdmin) => {
+        this.isAdmin = !!isAdmin;
+        if (this.isAdmin) {
+          this.emit('admin:verified');
+          console.log('[AUTH] Admin status verified');
+        }
+        resolve(this.isAdmin);
+      });
+    });
+  }
+
+  /**
+   * Logout
+   */
+  logout() {
+    this.gunModule.logout();
+    this.currentUser = null;
+    this.isAdmin = false;
+    localStorage.removeItem('whisperz_session');
+    this.emit('auth:logout');
+    console.log('[AUTH] User logged out');
+  }
+
+  /**
+   * Get current user
+   */
+  getCurrentUser() {
+    return this.currentUser;
+  }
+
+  /**
+   * Check if authenticated
+   */
+  isAuthenticated() {
+    return !!this.currentUser && this.gunModule.isAuthenticated;
+  }
+
+  async cleanup() {
+    this.logout();
+    this.removeAllListeners();
+  }
+}
+
+export default new AuthModule();
\ No newline at end of file
diff --git a/src/styles/main.css b/src/styles/main.css
new file mode 100644
index 0000000..4993521
--- /dev/null
+++ b/src/styles/main.css
@@ -0,0 +1,506 @@
+/* Whisperz - Clean Terminal Style */
+
+:root {
+  --bg-primary: #0a0a0a;
+  --bg-secondary: #141414;
+  --bg-terminal: #0d0d0d;
+  --text-primary: #00ff00;
+  --text-secondary: #008f00;
+  --text-dim: #005f00;
+  --border-color: #00ff00;
+  --error-color: #ff0040;
+  --warning-color: #ffaa00;
+  --accent: #00ffaa;
+}
+
+* {
+  margin: 0;
+  padding: 0;
+  box-sizing: border-box;
+}
+
+body {
+  font-family: 'Courier New', monospace;
+  background: var(--bg-primary);
+  color: var(--text-primary);
+  line-height: 1.6;
+  overflow: hidden;
+}
+
+#app {
+  width: 100vw;
+  height: 100vh;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+
+/* Screens */
+.screen {
+  display: none;
+  width: 100%;
+  height: 100%;
+  position: relative;
+}
+
+.screen.active {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+
+/* Terminal Window */
+.terminal {
+  background: var(--bg-terminal);
+  border: 1px solid var(--border-color);
+  border-radius: 0;
+  min-width: 600px;
+  box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
+}
+
+.terminal-header {
+  background: var(--bg-secondary);
+  padding: 10px 15px;
+  border-bottom: 1px solid var(--border-color);
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+.terminal-title {
+  color: var(--text-primary);
+  font-size: 14px;
+}
+
+.terminal-close {
+  background: none;
+  border: none;
+  color: var(--text-primary);
+  font-size: 20px;
+  cursor: pointer;
+  padding: 0 5px;
+}
+
+.terminal-close:hover {
+  color: var(--error-color);
+}
+
+.terminal-body {
+  padding: 30px;
+}
+
+/* ASCII Art */
+.ascii-art {
+  color: var(--text-primary);
+  font-size: 14px;
+  margin-bottom: 30px;
+  text-align: center;
+}
+
+/* Terminal Text */
+.terminal-text {
+  color: var(--text-secondary);
+  margin: 10px 0;
+  text-align: center;
+  font-size: 12px;
+  letter-spacing: 2px;
+}
+
+/* Terminal Input */
+.terminal-input {
+  margin-top: 40px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  gap: 15px;
+}
+
+.prompt {
+  color: var(--text-primary);
+  font-size: 16px;
+}
+
+/* Buttons */
+.terminal-btn {
+  background: none;
+  border: 1px solid var(--text-primary);
+  color: var(--text-primary);
+  padding: 8px 20px;
+  font-family: inherit;
+  font-size: 14px;
+  cursor: pointer;
+  text-transform: lowercase;
+  transition: all 0.2s;
+}
+
+.terminal-btn:hover {
+  background: var(--text-primary);
+  color: var(--bg-primary);
+}
+
+.terminal-btn.primary {
+  border-color: var(--accent);
+  color: var(--accent);
+}
+
+.terminal-btn.primary:hover {
+  background: var(--accent);
+  color: var(--bg-primary);
+}
+
+.terminal-btn.small {
+  padding: 5px 12px;
+  font-size: 12px;
+}
+
+.terminal-btn:disabled {
+  opacity: 0.3;
+  cursor: not-allowed;
+}
+
+/* Forms */
+.terminal-form {
+  max-width: 400px;
+  margin: 0 auto;
+}
+
+.form-group {
+  margin-bottom: 20px;
+  display: flex;
+  flex-direction: column;
+}
+
+.terminal-label {
+  color: var(--text-secondary);
+  font-size: 12px;
+  margin-bottom: 5px;
+  text-transform: lowercase;
+}
+
+.terminal-input-field {
+  background: var(--bg-primary);
+  border: 1px solid var(--text-dim);
+  color: var(--text-primary);
+  padding: 8px 12px;
+  font-family: inherit;
+  font-size: 14px;
+  outline: none;
+}
+
+.terminal-input-field:focus {
+  border-color: var(--text-primary);
+}
+
+.terminal-input-field::placeholder {
+  color: var(--text-dim);
+}
+
+/* Error Messages */
+.error-msg {
+  color: var(--error-color);
+  font-size: 12px;
+  margin-top: 10px;
+  text-align: center;
+}
+
+/* Main Interface */
+.main-container {
+  display: flex;
+  width: 100%;
+  height: 100%;
+}
+
+/* Sidebar */
+.sidebar {
+  width: 300px;
+  background: var(--bg-secondary);
+  border-right: 1px solid var(--border-color);
+  display: flex;
+  flex-direction: column;
+}
+
+.sidebar-header {
+  padding: 20px;
+  border-bottom: 1px solid var(--text-dim);
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+.user-info {
+  color: var(--text-primary);
+  font-size: 14px;
+}
+
+.sidebar-section {
+  padding: 20px;
+  border-bottom: 1px solid var(--text-dim);
+}
+
+.section-title {
+  color: var(--text-secondary);
+  font-size: 12px;
+  margin-bottom: 15px;
+  letter-spacing: 1px;
+}
+
+.contacts-list {
+  margin-bottom: 15px;
+}
+
+.contact-item {
+  padding: 8px 12px;
+  margin-bottom: 5px;
+  cursor: pointer;
+  border: 1px solid transparent;
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+.contact-item:hover {
+  border-color: var(--text-dim);
+}
+
+.contact-item.active {
+  background: var(--bg-primary);
+  border-color: var(--text-primary);
+}
+
+.contact-name {
+  font-size: 14px;
+}
+
+.contact-status {
+  width: 8px;
+  height: 8px;
+  border-radius: 50%;
+  background: var(--text-dim);
+}
+
+.contact-status.online {
+  background: var(--text-primary);
+}
+
+/* Chat Area */
+.chat-area {
+  flex: 1;
+  display: flex;
+  flex-direction: column;
+  background: var(--bg-primary);
+}
+
+.chat-header {
+  padding: 20px;
+  border-bottom: 1px solid var(--text-dim);
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+#chatTitle {
+  font-size: 16px;
+  color: var(--text-primary);
+}
+
+.status {
+  font-size: 12px;
+  color: var(--text-secondary);
+}
+
+/* Messages */
+.messages {
+  flex: 1;
+  padding: 20px;
+  overflow-y: auto;
+  display: flex;
+  flex-direction: column;
+  gap: 10px;
+}
+
+.message {
+  max-width: 70%;
+  padding: 10px 15px;
+  border: 1px solid var(--text-dim);
+  background: var(--bg-secondary);
+}
+
+.message.own {
+  align-self: flex-end;
+  border-color: var(--text-primary);
+}
+
+.message-header {
+  font-size: 10px;
+  color: var(--text-secondary);
+  margin-bottom: 5px;
+}
+
+.message-content {
+  font-size: 14px;
+  color: var(--text-primary);
+  word-wrap: break-word;
+}
+
+.message-time {
+  font-size: 10px;
+  color: var(--text-dim);
+  margin-top: 5px;
+}
+
+/* Chat Input */
+.chat-input {
+  padding: 20px;
+  border-top: 1px solid var(--text-dim);
+  display: flex;
+  gap: 10px;
+}
+
+.chat-input .terminal-input-field {
+  flex: 1;
+}
+
+/* Modal */
+.modal {
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  background: rgba(0, 0, 0, 0.8);
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  z-index: 1000;
+}
+
+.modal.hidden {
+  display: none;
+}
+
+.modal-content {
+  width: 90%;
+  max-width: 800px;
+  max-height: 80vh;
+  overflow: hidden;
+}
+
+.modal-content .terminal {
+  width: 100%;
+}
+
+.modal-content .terminal-body {
+  max-height: 60vh;
+  overflow-y: auto;
+}
+
+/* Admin Panel */
+.admin-tabs {
+  display: flex;
+  gap: 10px;
+  margin-bottom: 20px;
+  border-bottom: 1px solid var(--text-dim);
+  padding-bottom: 10px;
+}
+
+.tab-btn {
+  background: none;
+  border: none;
+  color: var(--text-secondary);
+  padding: 5px 15px;
+  cursor: pointer;
+  font-family: inherit;
+  font-size: 14px;
+}
+
+.tab-btn.active {
+  color: var(--text-primary);
+  border-bottom: 2px solid var(--text-primary);
+}
+
+.tab-content {
+  display: none;
+}
+
+.tab-content.active {
+  display: block;
+}
+
+.admin-actions {
+  margin-bottom: 20px;
+  display: flex;
+  gap: 10px;
+}
+
+.admin-list {
+  font-size: 12px;
+}
+
+.admin-list-item {
+  padding: 10px;
+  border: 1px solid var(--text-dim);
+  margin-bottom: 10px;
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+.admin-list-item:hover {
+  border-color: var(--text-primary);
+}
+
+.item-info {
+  flex: 1;
+}
+
+.item-actions {
+  display: flex;
+  gap: 5px;
+}
+
+/* Stats */
+.stats-content {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
+  gap: 20px;
+}
+
+.stat-item {
+  padding: 15px;
+  border: 1px solid var(--text-dim);
+}
+
+.stat-label {
+  font-size: 10px;
+  color: var(--text-secondary);
+  text-transform: uppercase;
+  margin-bottom: 5px;
+}
+
+.stat-value {
+  font-size: 24px;
+  color: var(--text-primary);
+}
+
+/* Scrollbar */
+::-webkit-scrollbar {
+  width: 8px;
+}
+
+::-webkit-scrollbar-track {
+  background: var(--bg-primary);
+}
+
+::-webkit-scrollbar-thumb {
+  background: var(--text-dim);
+  border: none;
+}
+
+::-webkit-scrollbar-thumb:hover {
+  background: var(--text-secondary);
+}
+
+/* Utilities */
+.hidden {
+  display: none !important;
+}
\ No newline at end of file
diff --git a/vite.config.js b/vite.config.js
new file mode 100644
index 0000000..1b20d99
--- /dev/null
+++ b/vite.config.js
@@ -0,0 +1,25 @@
+import { defineConfig } from 'vite';
+import { nodePolyfills } from 'vite-plugin-node-polyfills';
+
+export default defineConfig({
+  plugins: [
+    nodePolyfills({
+      globals: {
+        Buffer: true,
+        global: true,
+        process: true
+      }
+    })
+  ],
+  server: {
+    port: 3000,
+    host: true
+  },
+  build: {
+    target: 'esnext',
+    outDir: 'dist'
+  },
+  optimizeDeps: {
+    exclude: ['gun', 'gun/sea']
+  }
+});
\ No newline at end of file
-- 
2.48.1

